package org.gol.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.gol.gol.Game
import org.gol.gol.Rule

class GolGenerator extends AbstractGenerator {

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val root = resource.allContents.head as Game
        
        fsa.generateFile('GameOfLife/RulesOfLife.java',
            '''
            package GameOfLife;
            
            import java.awt.Point;
            import java.util.ArrayList;
            import java.util.Arrays;
            import java.util.HashSet;
            
            public class RulesOfLife {
                public static int gridWidth = «root.grid.size.width»;
                public static int gridHeight = «root.grid.size.height»;
                
                public static HashSet<Point> Glider = new HashSet<Point>(
                    Arrays.asList(
                        new Point(4,3), new Point(5,4), new Point(5,5), new Point(4,5), new Point(3,5)
                    )
                );
                public static HashSet<Point> Blinker = new HashSet<Point>(
                    Arrays.asList(
                        new Point(3,3), new Point(3,4), new Point(21,20), new Point(3,5)
                    )
                );

                public static ArrayList<Point> populatedCells;
                public static HashSet<Point> initialCells;
                
                static {
                    initialCells = new HashSet<Point>(
                        Arrays.asList(
                            «FOR populatedCell: Auxiliary.getStartingPoints(root.grid) SEPARATOR ', '»
                                new Point(«populatedCell.x»,«populatedCell.y»)
                            «ENDFOR»
                        )
                    );
                    
                    «FOR preset: Auxiliary.getPesets(root.grid)»
                        initialCells.addAll(«preset»);
                    «ENDFOR»
                    
                    populatedCells = new ArrayList<>(initialCells);
                }
                 
                public static void computeSurvivors(boolean[][] gameBoard, ArrayList<Point> survivingCells) {
                    for (int i=1; i<gameBoard.length-1; i++) {
                        for (int j=1; j<gameBoard[0].length-1; j++) {
                            int surrounding = 0;
                            if (gameBoard[i-1][j-1]) { surrounding++; }
                            if (gameBoard[i-1][j])   { surrounding++; }
                            if (gameBoard[i-1][j+1]) { surrounding++; }
                            if (gameBoard[i][j-1])   { surrounding++; }
                            if (gameBoard[i][j+1])   { surrounding++; }
                            if (gameBoard[i+1][j-1]) { surrounding++; }
                            if (gameBoard[i+1][j])   { surrounding++; }
                            if (gameBoard[i+1][j+1]) { surrounding++; }
                            
                            «FOR rule: Auxiliary.getRules(root)»
                                «rule2Text(rule)»
                            «ENDFOR»
                        }
                    }
                }
            }
            '''
        )
    }

    def static dispatch rule2Text(Rule rule) '''
        if ((«IF rule.state == "dead"»!«ENDIF»gameBoard[i][j]) && 
        «FOR condition: Auxiliary.getConditions(rule)»
        (surrounding «condition.boolOp» «condition.NCount») «IF condition.separator == "||"»||«ENDIF»«IF condition.separator == "&&"»&&«ENDIF»
        «ENDFOR»){
            «IF rule.result == "survives"»survivingCells.add(new Point(i-1,j-1));«ENDIF»
            «IF rule.result == "populates"»survivingCells.add(new Point(i-1,j-1));«ENDIF»
            «IF rule.result == "dies"»
                Point pointToRemove = new Point(i-1, j-1);
                survivingCells.removeIf(point -> point.equals(pointToRemove));
            «ENDIF»
        }
    ''' 
}